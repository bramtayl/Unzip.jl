var documenterSearchIndex = {"docs":
[{"location":"#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"","page":"Interface","title":"Interface","text":"Modules = [Unzip]","category":"page"},{"location":"","page":"Interface","title":"Interface","text":"Modules = [Unzip]","category":"page"},{"location":"#Unzip.unzip-Tuple{Any}","page":"Interface","title":"Unzip.unzip","text":"unzip(rows)\n\nCollect into columns.\n\nWill be most performant if each row is a tuple. If each row is not a tuple, consider using unzip(Iterators.map(Tuple, rows)).\n\njulia> using Unzip\n\njulia> using Test: @inferred\n\njulia> stable(x) = (x, x + 0.0, x, x + 0.0, x, x + 0.0);\n\njulia> @inferred unzip(Iterators.map(stable, 1:4))\n([1, 2, 3, 4], [1.0, 2.0, 3.0, 4.0], [1, 2, 3, 4], [1.0, 2.0, 3.0, 4.0], [1, 2, 3, 4], [1.0, 2.0, 3.0, 4.0])\n\njulia> unstable(x) =\n           if x == 2\n               (x, x + 0.0, x, x + 0.0)\n           else\n               (x, x + 0.0)\n           end;\n\njulia> unzip(Iterators.map(unstable, 1:3))\n([1, 2, 3], [1.0, 2.0, 3.0], Union{Missing, Int64}[missing, 2, missing], Union{Missing, Float64}[missing, 2.0, missing])\n\n\n\n\n\n","category":"method"}]
}
